Debug = true

[33m[stage-9] [0m[94mRunning tests for Stage #9: av4[0m
[33m[stage-9] [test-1] [0m[94mRunning test case: 1[0m
[33m[stage-9] [test-1] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-9] [test-1.lox] [0mprint clock() + 23;
[33m[stage-9] [test-1] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m1.741238639464E9
[33m[stage-9] [test-1] [0m[92mâœ“ 1741238639.464000[0m
[33m[stage-9] [test-1] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-9] [test-1] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-9] [test-2] [0m[94mRunning test case: 2[0m
[33m[stage-9] [test-2] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-9] [test-2.lox] [0mprint clock() / 1000;
[33m[stage-9] [test-2] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m1741238.616527
[33m[stage-9] [test-2] [0m[92mâœ“ 1741238.616527[0m
[33m[stage-9] [test-2] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-9] [test-2] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-9] [test-3] [0m[94mRunning test case: 3[0m
[33m[stage-9] [test-3] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-9] [test-3.lox] [0m// This program utilizes the built-in clock() function
[33m[stage-9] [test-3.lox] [0m// and runs a check to see if the operation has timed out
[33m[stage-9] [test-3.lox] [0mvar startTime = clock();
[33m[stage-9] [test-3.lox] [0mvar timeoutSeconds = 2;
[33m[stage-9] [test-3.lox] [0m
[33m[stage-9] [test-3.lox] [0m// Check if less than 2 seconds have elapsed
[33m[stage-9] [test-3.lox] [0mif ((clock() >= startTime) and (clock() <= (startTime + timeoutSeconds))) {
[33m[stage-9] [test-3.lox] [0m  print "Operation in progress...";
[33m[stage-9] [test-3.lox] [0m} else {
[33m[stage-9] [test-3.lox] [0m  print "Operation timed out!";
[33m[stage-9] [test-3.lox] [0m}
[33m[stage-9] [test-3] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mOperation in progress...
[33m[stage-9] [test-3] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-9] [test-3] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-9] [test-4] [0m[94mRunning test case: 4[0m
[33m[stage-9] [test-4] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-9] [test-4.lox] [0m// This program utilizes the built-in clock() function
[33m[stage-9] [test-4.lox] [0m// to create a timer that runs for 0.2 seconds
[33m[stage-9] [test-4.lox] [0mvar startTime = clock();
[33m[stage-9] [test-4.lox] [0mvar lastCheck = startTime;
[33m[stage-9] [test-4.lox] [0mvar running = true;
[33m[stage-9] [test-4.lox] [0m
[33m[stage-9] [test-4.lox] [0mprint "Starting timer for 0.2 seconds";
[33m[stage-9] [test-4.lox] [0mvar startTime = clock();
[33m[stage-9] [test-4.lox] [0m
[33m[stage-9] [test-4.lox] [0mwhile (running) {
[33m[stage-9] [test-4.lox] [0m  if (clock() > startTime + 0.2) {
[33m[stage-9] [test-4.lox] [0m    print "Timer ended";
[33m[stage-9] [test-4.lox] [0m    running = false;
[33m[stage-9] [test-4.lox] [0m  }
[33m[stage-9] [test-4.lox] [0m}
[33m[stage-9] [test-4] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mStarting timer for 0.2 seconds
[33m[your_program] [0mTimer ended
[33m[stage-9] [test-4] [0m[92mâœ“ 2 line(s) match on stdout[0m
[33m[stage-9] [test-4] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-9] [0m[92mTest passed.[0m

[33m[stage-8] [0m[94mRunning tests for Stage #8: pg8[0m
[33m[stage-8] [test-1] [0m[94mRunning test case: 1[0m
[33m[stage-8] [test-1] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-8] [test-1.lox] [0m// This program defines a simple function that doesn't take any arguments
[33m[stage-8] [test-1.lox] [0m// and then invokes the function
[33m[stage-8] [test-1.lox] [0mfun hello() { print 55; }
[33m[stage-8] [test-1.lox] [0mhello();
[33m[stage-8] [test-1] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m55
[33m[stage-8] [test-1] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-8] [test-1] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-8] [test-2] [0m[94mRunning test case: 2[0m
[33m[stage-8] [test-2] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-8] [test-2.lox] [0m// This function, when invoked should not return or print anything
[33m[stage-8] [test-2.lox] [0mfun f() {}
[33m[stage-8] [test-2.lox] [0mf();
[33m[stage-8] [test-2] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[stage-8] [test-2] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-8] [test-2] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-8] [test-3] [0m[94mRunning test case: 3[0m
[33m[stage-8] [test-3] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-8] [test-3.lox] [0m// This program should print <fn foo>
[33m[stage-8] [test-3.lox] [0mfun foo() {}
[33m[stage-8] [test-3.lox] [0mprint foo;
[33m[stage-8] [test-3] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m<fn foo>
[33m[stage-8] [test-3] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-8] [test-3] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-8] [test-4] [0m[94mRunning test case: 4[0m
[33m[stage-8] [test-4] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-8] [test-4.lox] [0m// This program calculates the cumulative sum of numbers from 1 to n.
[33m[stage-8] [test-4.lox] [0mfun cumulative_sum() {
[33m[stage-8] [test-4.lox] [0m    var n = 10;  // Fixed value
[33m[stage-8] [test-4.lox] [0m    var total = 0;
[33m[stage-8] [test-4.lox] [0m    var i = 1;
[33m[stage-8] [test-4.lox] [0m    while (i <= n) {
[33m[stage-8] [test-4.lox] [0m        total = total + i;
[33m[stage-8] [test-4.lox] [0m        i = i + 1;
[33m[stage-8] [test-4.lox] [0m    }
[33m[stage-8] [test-4.lox] [0m    print "The cumulative sum from 1 to 10 is: ";
[33m[stage-8] [test-4.lox] [0m    print total;
[33m[stage-8] [test-4.lox] [0m}
[33m[stage-8] [test-4.lox] [0m
[33m[stage-8] [test-4.lox] [0mcumulative_sum();
[33m[stage-8] [test-4] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mThe cumulative sum from 1 to 10 is: 
[33m[your_program] [0m55
[33m[stage-8] [test-4] [0m[92mâœ“ 2 line(s) match on stdout[0m
[33m[stage-8] [test-4] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-8] [0m[92mTest passed.[0m

[33m[stage-7] [0m[94mRunning tests for Stage #7: lb6[0m
[33m[stage-7] [test-1] [0m[94mRunning test case: 1[0m
[33m[stage-7] [test-1] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-7] [test-1.lox] [0m// This is a simple function that takes one argument and prints it
[33m[stage-7] [test-1.lox] [0mfun f1(a) { print a; }
[33m[stage-7] [test-1.lox] [0mf1(45);
[33m[stage-7] [test-1] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m45
[33m[stage-7] [test-1] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-7] [test-1] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-7] [test-2] [0m[94mRunning test case: 2[0m
[33m[stage-7] [test-2] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-7] [test-2.lox] [0m// This function takes three arguments and prints their sum
[33m[stage-7] [test-2.lox] [0mfun f3(a, b, c) { print a + b + c; }
[33m[stage-7] [test-2.lox] [0mf3(67, 67, 67);
[33m[stage-7] [test-2] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m201
[33m[stage-7] [test-2] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-7] [test-2] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-7] [test-3] [0m[94mRunning test case: 3[0m
[33m[stage-7] [test-3] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-7] [test-3.lox] [0m// This function takes eight arguments and prints their sum
[33m[stage-7] [test-3.lox] [0mfun f8(a, b, c, d, e, f, g, h) { print a - b + c * d + e - f + g - h; }
[33m[stage-7] [test-3.lox] [0mf8(29, 29, 29, 29, 29, 29, 29, 29);
[33m[stage-7] [test-3] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m841
[33m[stage-7] [test-3] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-7] [test-3] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-7] [test-4] [0m[94mRunning test case: 4[0m
[33m[stage-7] [test-4] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-7] [test-4.lox] [0m// This function takes two arguments and prints the grade based on the score and bonus
[33m[stage-7] [test-4.lox] [0mfun calculateGrade(score, bonus) {
[33m[stage-7] [test-4.lox] [0m  var finalScore = score + bonus;
[33m[stage-7] [test-4.lox] [0m
[33m[stage-7] [test-4.lox] [0m  if (finalScore >= 90) {
[33m[stage-7] [test-4.lox] [0m    print "A";
[33m[stage-7] [test-4.lox] [0m  } else if (finalScore >= 80) {
[33m[stage-7] [test-4.lox] [0m    print "B";
[33m[stage-7] [test-4.lox] [0m  } else if (finalScore >= 70) {
[33m[stage-7] [test-4.lox] [0m    print "C";
[33m[stage-7] [test-4.lox] [0m  } else if (finalScore >= 60) {
[33m[stage-7] [test-4.lox] [0m    print "D";
[33m[stage-7] [test-4.lox] [0m  } else {
[33m[stage-7] [test-4.lox] [0m    print "F";
[33m[stage-7] [test-4.lox] [0m  }
[33m[stage-7] [test-4.lox] [0m}
[33m[stage-7] [test-4.lox] [0m
[33m[stage-7] [test-4.lox] [0mvar score = 64;
[33m[stage-7] [test-4.lox] [0mvar bonus = 3;
[33m[stage-7] [test-4.lox] [0mprint "Grade for given score is: ";
[33m[stage-7] [test-4.lox] [0mcalculateGrade(score, bonus);
[33m[stage-7] [test-4] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mGrade for given score is: 
[33m[your_program] [0mD
[33m[stage-7] [test-4] [0m[92mâœ“ 2 line(s) match on stdout[0m
[33m[stage-7] [test-4] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-7] [0m[92mTest passed.[0m

[33m[stage-6] [0m[94mRunning tests for Stage #6: px4[0m
[33m[stage-6] [test-1] [0m[94mRunning test case: 1[0m
[33m[stage-6] [test-1] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-6] [test-1.lox] [0m// This program is missing the closing parenthesis for the function call
[33m[stage-6] [test-1.lox] [0m// Hence the compiler error
[33m[stage-6] [test-1.lox] [0mprint clock(;
[33m[stage-6] [test-1] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m[line 3] Error at ';': Expect expression.
[33m[stage-6] [test-1] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-6] [test-1] [0m[92mâœ“ Received exit code 65.[0m
[33m[stage-6] [test-2] [0m[94mRunning test case: 2[0m
[33m[stage-6] [test-2] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-6] [test-2.lox] [0m// This program is missing the opening parenthesis for the function call,
[33m[stage-6] [test-2.lox] [0m// and has extra closing parentheses
[33m[stage-6] [test-2.lox] [0m// Hence the compiler error
[33m[stage-6] [test-2.lox] [0mprint clock)));
[33m[stage-6] [test-2] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m[line 4] Error at ')': Expect ';' after value.
[33m[stage-6] [test-2] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-6] [test-2] [0m[92mâœ“ Received exit code 65.[0m
[33m[stage-6] [test-3] [0m[94mRunning test case: 3[0m
[33m[stage-6] [test-3] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-6] [test-3.lox] [0m// This function declaration is missing the opening and closing braces
[33m[stage-6] [test-3.lox] [0m// The body should always be inside a block
[33m[stage-6] [test-3.lox] [0m// Hence the compiler error
[33m[stage-6] [test-3.lox] [0mfun f() 27;
[33m[stage-6] [test-3.lox] [0mprint f();
[33m[stage-6] [test-3] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m[line 4] Error at '27': Expect '{' before function body.
[33m[stage-6] [test-3] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-6] [test-3] [0m[92mâœ“ Received exit code 65.[0m
[33m[stage-6] [test-4] [0m[94mRunning test case: 4[0m
[33m[stage-6] [test-4] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-6] [test-4.lox] [0m// This function declaration is missing a comma between b and c
[33m[stage-6] [test-4.lox] [0m// Hence the compiler error
[33m[stage-6] [test-4.lox] [0mfun foo(a, b c, d, e, f) {}
[33m[stage-6] [test-4.lox] [0mfoo();
[33m[stage-6] [test-4] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m[line 3] Error at 'c': Expect ')' after parameters.
[33m[stage-6] [test-4] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-6] [test-4] [0m[92mâœ“ Received exit code 65.[0m
[33m[stage-6] [0m[92mTest passed.[0m

[33m[stage-5] [0m[94mRunning tests for Stage #5: rd2[0m
[33m[stage-5] [test-1] [0m[94mRunning test case: 1[0m
[33m[stage-5] [test-1] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-5] [test-1.lox] [0m// This program computes the 35th Fibonacci number
[33m[stage-5] [test-1.lox] [0mfun fib(n) {
[33m[stage-5] [test-1.lox] [0m  if (n < 2) return n;
[33m[stage-5] [test-1.lox] [0m  return fib(n - 2) + fib(n - 1);
[33m[stage-5] [test-1.lox] [0m}
[33m[stage-5] [test-1.lox] [0m
[33m[stage-5] [test-1.lox] [0mvar start = clock();
[33m[stage-5] [test-1.lox] [0mprint fib(10) == 55;
[33m[stage-5] [test-1.lox] [0mprint (clock() - start) < 5; // 5 seconds
[33m[stage-5] [test-1] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mtrue
[33m[your_program] [0mtrue
[33m[stage-5] [test-1] [0m[92mâœ“ 2 line(s) match on stdout[0m
[33m[stage-5] [test-1] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-5] [test-2] [0m[94mRunning test case: 2[0m
[33m[stage-5] [test-2] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-5] [test-2.lox] [0m// This program uses a return statement inside an if statement
[33m[stage-5] [test-2.lox] [0m// to return "ok" if the condition is false
[33m[stage-5] [test-2.lox] [0mfun f() {
[33m[stage-5] [test-2.lox] [0m  if (true) return "no"; else return "ok";
[33m[stage-5] [test-2.lox] [0m}
[33m[stage-5] [test-2.lox] [0m
[33m[stage-5] [test-2.lox] [0mprint f();
[33m[stage-5] [test-2] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mno
[33m[stage-5] [test-2] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-5] [test-2] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-5] [test-3] [0m[94mRunning test case: 3[0m
[33m[stage-5] [test-3] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-5] [test-3.lox] [0m// This program uses a return statement inside a while loop
[33m[stage-5] [test-3.lox] [0m// to return "ok" if the condition is false
[33m[stage-5] [test-3.lox] [0mfun f() {
[33m[stage-5] [test-3.lox] [0m  while (!false) return "ok";
[33m[stage-5] [test-3.lox] [0m}
[33m[stage-5] [test-3.lox] [0m
[33m[stage-5] [test-3.lox] [0mprint f();
[33m[stage-5] [test-3] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mok
[33m[stage-5] [test-3] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-5] [test-3] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-5] [test-4] [0m[94mRunning test case: 4[0m
[33m[stage-5] [test-4] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-5] [test-4.lox] [0m// This program relies on the return statement returning nil by default
[33m[stage-5] [test-4.lox] [0mfun f() {
[33m[stage-5] [test-4.lox] [0m  return;
[33m[stage-5] [test-4.lox] [0m  print "bad";
[33m[stage-5] [test-4.lox] [0m}
[33m[stage-5] [test-4.lox] [0m
[33m[stage-5] [test-4.lox] [0mprint f();
[33m[stage-5] [test-4] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mnil
[33m[stage-5] [test-4] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-5] [test-4] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-5] [0m[92mTest passed.[0m

[33m[stage-4] [0m[94mRunning tests for Stage #4: ey3[0m
[33m[stage-4] [test-1] [0m[94mRunning test case: 1[0m
[33m[stage-4] [test-1] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-4] [test-1.lox] [0m// This program creates a function that returns another function
[33m[stage-4] [test-1.lox] [0m// and uses it to greet two different people with two different greetings
[33m[stage-4] [test-1.lox] [0mvar globalGreeting = "Hello";
[33m[stage-4] [test-1.lox] [0m
[33m[stage-4] [test-1.lox] [0mfun makeGreeter() {
[33m[stage-4] [test-1.lox] [0m  fun greet(name) {
[33m[stage-4] [test-1.lox] [0m    print globalGreeting + " " + name;
[33m[stage-4] [test-1.lox] [0m  }
[33m[stage-4] [test-1.lox] [0m  return greet;
[33m[stage-4] [test-1.lox] [0m}
[33m[stage-4] [test-1.lox] [0m
[33m[stage-4] [test-1.lox] [0mvar sayHello = makeGreeter();
[33m[stage-4] [test-1.lox] [0m
[33m[stage-4] [test-1.lox] [0msayHello("Bob");
[33m[stage-4] [test-1.lox] [0msayHello("Alice");
[33m[stage-4] [test-1.lox] [0msayHello("Eve");
[33m[stage-4] [test-1] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mHello Bob
[33m[your_program] [0mHello Alice
[33m[your_program] [0mHello Eve
[33m[stage-4] [test-1] [0m[92mâœ“ 3 line(s) match on stdout[0m
[33m[stage-4] [test-1] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-4] [test-2] [0m[94mRunning test case: 2[0m
[33m[stage-4] [test-2] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-4] [test-2.lox] [0m// This program defines a function that takes in a function and an argument
[33m[stage-4] [test-2.lox] [0m// and returns the result of calling the function with the argument
[33m[stage-4] [test-2.lox] [0mfun returnArg(arg) {
[33m[stage-4] [test-2.lox] [0m  return arg;
[33m[stage-4] [test-2.lox] [0m}
[33m[stage-4] [test-2.lox] [0m
[33m[stage-4] [test-2.lox] [0mfun returnFunCallWithArg(func, arg) {
[33m[stage-4] [test-2.lox] [0m  return returnArg(func)(arg);
[33m[stage-4] [test-2.lox] [0m}
[33m[stage-4] [test-2.lox] [0m
[33m[stage-4] [test-2.lox] [0mfun printArg(arg) {
[33m[stage-4] [test-2.lox] [0m  print arg;
[33m[stage-4] [test-2.lox] [0m}
[33m[stage-4] [test-2.lox] [0m
[33m[stage-4] [test-2.lox] [0mreturnFunCallWithArg(printArg, "world");
[33m[stage-4] [test-2] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mworld
[33m[stage-4] [test-2] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-4] [test-2] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-4] [test-3] [0m[94mRunning test case: 3[0m
[33m[stage-4] [test-3] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-4] [test-3.lox] [0mfun square(x) {
[33m[stage-4] [test-3.lox] [0m  return x * x;
[33m[stage-4] [test-3.lox] [0m}
[33m[stage-4] [test-3.lox] [0m
[33m[stage-4] [test-3.lox] [0m// This higher-order function applies a
[33m[stage-4] [test-3.lox] [0m// function N times to a starting value x.
[33m[stage-4] [test-3.lox] [0mfun applyTimesN(N, f, x) {
[33m[stage-4] [test-3.lox] [0m  var i = 0;
[33m[stage-4] [test-3.lox] [0m  while (i < N) {
[33m[stage-4] [test-3.lox] [0m    x = f(x);
[33m[stage-4] [test-3.lox] [0m    i = i + 1;
[33m[stage-4] [test-3.lox] [0m  }
[33m[stage-4] [test-3.lox] [0m  return x;
[33m[stage-4] [test-3.lox] [0m}
[33m[stage-4] [test-3.lox] [0m
[33m[stage-4] [test-3.lox] [0m// 2 is squared once
[33m[stage-4] [test-3.lox] [0mprint applyTimesN(1, square, 2);
[33m[stage-4] [test-3.lox] [0m// 2 is squared twice
[33m[stage-4] [test-3.lox] [0mprint applyTimesN(2, square, 2);
[33m[stage-4] [test-3.lox] [0m// 2 is squared thrice
[33m[stage-4] [test-3.lox] [0mprint applyTimesN(3, square, 2);
[33m[stage-4] [test-3] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m4
[33m[your_program] [0m16
[33m[your_program] [0m256
[33m[stage-4] [test-3] [0m[92mâœ“ 3 line(s) match on stdout[0m
[33m[stage-4] [test-3] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-4] [test-4] [0m[94mRunning test case: 4[0m
[33m[stage-4] [test-4] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-4] [test-4.lox] [0m// This program creates a function that returns another function
[33m[stage-4] [test-4.lox] [0m// and uses it to filter a list of numbers
[33m[stage-4] [test-4.lox] [0mfun makeFilter(min) {
[33m[stage-4] [test-4.lox] [0m  fun filter(n) {
[33m[stage-4] [test-4.lox] [0m    if (n < min) {
[33m[stage-4] [test-4.lox] [0m      return false;
[33m[stage-4] [test-4.lox] [0m    }
[33m[stage-4] [test-4.lox] [0m    return true;
[33m[stage-4] [test-4.lox] [0m  }
[33m[stage-4] [test-4.lox] [0m  return filter;
[33m[stage-4] [test-4.lox] [0m}
[33m[stage-4] [test-4.lox] [0m
[33m[stage-4] [test-4.lox] [0m// This function applies a function to a list of numbers
[33m[stage-4] [test-4.lox] [0mfun applyToNumbers(f, count) {
[33m[stage-4] [test-4.lox] [0m  var n = 0;
[33m[stage-4] [test-4.lox] [0m  while (n < count) {
[33m[stage-4] [test-4.lox] [0m    if (f(n)) {
[33m[stage-4] [test-4.lox] [0m      print n;
[33m[stage-4] [test-4.lox] [0m    }
[33m[stage-4] [test-4.lox] [0m    n = n + 1;
[33m[stage-4] [test-4.lox] [0m  }
[33m[stage-4] [test-4.lox] [0m}
[33m[stage-4] [test-4.lox] [0m
[33m[stage-4] [test-4.lox] [0mvar greaterThanX = makeFilter(54);
[33m[stage-4] [test-4.lox] [0mvar greaterThanY = makeFilter(44);
[33m[stage-4] [test-4.lox] [0m
[33m[stage-4] [test-4.lox] [0mprint "Numbers >= 54:";
[33m[stage-4] [test-4.lox] [0mapplyToNumbers(greaterThanX, 54 + 6);
[33m[stage-4] [test-4.lox] [0m
[33m[stage-4] [test-4.lox] [0mprint "Numbers >= 44:";
[33m[stage-4] [test-4.lox] [0mapplyToNumbers(greaterThanY, 44 + 6);
[33m[stage-4] [test-4] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mNumbers >= 54:
[33m[your_program] [0m54
[33m[your_program] [0m55
[33m[your_program] [0m56
[33m[your_program] [0m57
[33m[your_program] [0m58
[33m[your_program] [0m59
[33m[your_program] [0mNumbers >= 44:
[33m[your_program] [0m44
[33m[your_program] [0m45
[33m[your_program] [0m46
[33m[your_program] [0m47
[33m[your_program] [0m48
[33m[your_program] [0m49
[33m[stage-4] [test-4] [0m[92mâœ“ 14 line(s) match on stdout[0m
[33m[stage-4] [test-4] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-4] [0m[92mTest passed.[0m

[33m[stage-3] [0m[94mRunning tests for Stage #3: fj7[0m
[33m[stage-3] [test-1] [0m[94mRunning test case: 1[0m
[33m[stage-3] [test-1] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-3] [test-1.lox] [0m// This program tries to execute an integer as a function
[33m[stage-3] [test-1.lox] [0m25();
[33m[stage-3] [test-1] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mCan only call functions and classes.
[33m[your_program] [0m[line 2]
[33m[stage-3] [test-1] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-3] [test-1] [0m[92mâœ“ Received exit code 70.[0m
[33m[stage-3] [test-2] [0m[94mRunning test case: 2[0m
[33m[stage-3] [test-2] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-3] [test-2.lox] [0m// This program tries to call a function with too many arguments
[33m[stage-3] [test-2.lox] [0mfun f(a, b) {
[33m[stage-3] [test-2.lox] [0m  print a;
[33m[stage-3] [test-2.lox] [0m  print b;
[33m[stage-3] [test-2.lox] [0m}
[33m[stage-3] [test-2.lox] [0m
[33m[stage-3] [test-2.lox] [0mf(1, 2, 3, 4); // expect runtime error: Expected 2 arguments but got 4.
[33m[stage-3] [test-2] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mExpected 2 arguments but got 4.
[33m[your_program] [0m[line 7]
[33m[stage-3] [test-2] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-3] [test-2] [0m[92mâœ“ Received exit code 70.[0m
[33m[stage-3] [test-3] [0m[94mRunning test case: 3[0m
[33m[stage-3] [test-3] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-3] [test-3.lox] [0m// This program tries to call a function with too few arguments
[33m[stage-3] [test-3.lox] [0mfun f(a, b) {}
[33m[stage-3] [test-3.lox] [0m
[33m[stage-3] [test-3.lox] [0mf(1); // expect runtime error: Expected 2 arguments but got 1.
[33m[stage-3] [test-3] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mExpected 2 arguments but got 1.
[33m[your_program] [0m[line 4]
[33m[stage-3] [test-3] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-3] [test-3] [0m[92mâœ“ Received exit code 70.[0m
[33m[stage-3] [test-4] [0m[94mRunning test case: 4[0m
[33m[stage-3] [test-4] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-3] [test-4.lox] [0m// This program tries to execute a boolean as a function
[33m[stage-3] [test-4.lox] [0m(false == false)();
[33m[stage-3] [test-4] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mCan only call functions and classes.
[33m[your_program] [0m[line 2]
[33m[stage-3] [test-4] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-3] [test-4] [0m[92mâœ“ Received exit code 70.[0m
[33m[stage-3] [0m[92mTest passed.[0m

[33m[stage-2] [0m[94mRunning tests for Stage #2: bz4[0m
[33m[stage-2] [test-1] [0m[94mRunning test case: 1[0m
[33m[stage-2] [test-1] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-2] [test-1.lox] [0m// This program demonstrates global and local variable shadowing in Lox.
[33m[stage-2] [test-1.lox] [0mvar a = 81;
[33m[stage-2] [test-1.lox] [0m
[33m[stage-2] [test-1.lox] [0mfun printAndModify() {
[33m[stage-2] [test-1.lox] [0m  print a;
[33m[stage-2] [test-1.lox] [0m  var a = 89;
[33m[stage-2] [test-1.lox] [0m  print a;
[33m[stage-2] [test-1.lox] [0m}
[33m[stage-2] [test-1.lox] [0m
[33m[stage-2] [test-1.lox] [0mprint a;
[33m[stage-2] [test-1.lox] [0ma = 59;
[33m[stage-2] [test-1.lox] [0mprintAndModify();
[33m[stage-2] [test-1] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m81
[33m[your_program] [0m59
[33m[your_program] [0m89
[33m[stage-2] [test-1] [0m[92mâœ“ 3 line(s) match on stdout[0m
[33m[stage-2] [test-1] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-2] [test-2] [0m[94mRunning test case: 2[0m
[33m[stage-2] [test-2] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-2] [test-2.lox] [0m// This program uses a while loop to count down from 3 to 1, printing each number
[33m[stage-2] [test-2.lox] [0m// and then decrementing the count until it reaches 0, at which point it prints
[33m[stage-2] [test-2.lox] [0m// "Blast off!"
[33m[stage-2] [test-2.lox] [0mvar count = 3;
[33m[stage-2] [test-2.lox] [0m
[33m[stage-2] [test-2.lox] [0mfun tick() {
[33m[stage-2] [test-2.lox] [0m  if (count > 0) {
[33m[stage-2] [test-2.lox] [0m    print count;
[33m[stage-2] [test-2.lox] [0m    count = count - 1;
[33m[stage-2] [test-2.lox] [0m    return false;
[33m[stage-2] [test-2.lox] [0m  }
[33m[stage-2] [test-2.lox] [0m  print "Blast off!";
[33m[stage-2] [test-2.lox] [0m  return true;
[33m[stage-2] [test-2.lox] [0m}
[33m[stage-2] [test-2.lox] [0m
[33m[stage-2] [test-2.lox] [0mwhile (!tick()) {}
[33m[stage-2] [test-2] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m3
[33m[your_program] [0m2
[33m[your_program] [0m1
[33m[your_program] [0mBlast off!
[33m[stage-2] [test-2] [0m[92mâœ“ 4 line(s) match on stdout[0m
[33m[stage-2] [test-2] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-2] [test-3] [0m[94mRunning test case: 3[0m
[33m[stage-2] [test-3] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-2] [test-3.lox] [0m// This program demonstrates variable shadowing in Lox with functions.
[33m[stage-2] [test-3.lox] [0m// The first counter is a global variable that is modified by the inner block.
[33m[stage-2] [test-3.lox] [0m// The second counter is a local variable that shadows the global variable.
[33m[stage-2] [test-3.lox] [0mvar counter = 93;
[33m[stage-2] [test-3.lox] [0m
[33m[stage-2] [test-3.lox] [0mfun incrementCounter(amount) {
[33m[stage-2] [test-3.lox] [0m  counter = counter + amount;
[33m[stage-2] [test-3.lox] [0m  print counter;
[33m[stage-2] [test-3.lox] [0m}
[33m[stage-2] [test-3.lox] [0m
[33m[stage-2] [test-3.lox] [0m{
[33m[stage-2] [test-3.lox] [0m  counter = 97;
[33m[stage-2] [test-3.lox] [0m  incrementCounter(5);
[33m[stage-2] [test-3.lox] [0m  print counter;
[33m[stage-2] [test-3.lox] [0m}
[33m[stage-2] [test-3.lox] [0mprint counter;
[33m[stage-2] [test-3] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m102
[33m[your_program] [0m102
[33m[your_program] [0m102
[33m[stage-2] [test-3] [0m[92mâœ“ 3 line(s) match on stdout[0m
[33m[stage-2] [test-3] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-2] [test-4] [0m[94mRunning test case: 4[0m
[33m[stage-2] [test-4] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-2] [test-4.lox] [0m// This program tests variable scoping and shadowing in Lox. It demonstrates:
[33m[stage-2] [test-4.lox] [0m// Global variable declarations
[33m[stage-2] [test-4.lox] [0m// Function scope access to global variables
[33m[stage-2] [test-4.lox] [0m// Block scoping with local variables shadowing outer variables
[33m[stage-2] [test-4.lox] [0m// Verification that global variables remain unchanged after shadowing
[33m[stage-2] [test-4.lox] [0mvar x = 1;
[33m[stage-2] [test-4.lox] [0mvar y = 2;
[33m[stage-2] [test-4.lox] [0m
[33m[stage-2] [test-4.lox] [0mfun printBoth() {
[33m[stage-2] [test-4.lox] [0m  if (x < y) {
[33m[stage-2] [test-4.lox] [0m    print "x is less than y:";
[33m[stage-2] [test-4.lox] [0m    print x;
[33m[stage-2] [test-4.lox] [0m    print y;
[33m[stage-2] [test-4.lox] [0m  } else {
[33m[stage-2] [test-4.lox] [0m    print "x is not less than y:";
[33m[stage-2] [test-4.lox] [0m    print x;
[33m[stage-2] [test-4.lox] [0m    print y;
[33m[stage-2] [test-4.lox] [0m  }
[33m[stage-2] [test-4.lox] [0m}
[33m[stage-2] [test-4.lox] [0m
[33m[stage-2] [test-4.lox] [0m{
[33m[stage-2] [test-4.lox] [0m  var x = 10;
[33m[stage-2] [test-4.lox] [0m  {
[33m[stage-2] [test-4.lox] [0m    var y = 20;
[33m[stage-2] [test-4.lox] [0m
[33m[stage-2] [test-4.lox] [0m    var i = 0;
[33m[stage-2] [test-4.lox] [0m    while (i < 3) {
[33m[stage-2] [test-4.lox] [0m      x = x + 1;
[33m[stage-2] [test-4.lox] [0m      y = y - 1;
[33m[stage-2] [test-4.lox] [0m      print "Local x: ";
[33m[stage-2] [test-4.lox] [0m      print x;
[33m[stage-2] [test-4.lox] [0m      print "Local y: ";
[33m[stage-2] [test-4.lox] [0m      print y;
[33m[stage-2] [test-4.lox] [0m      i = i + 1;
[33m[stage-2] [test-4.lox] [0m    }
[33m[stage-2] [test-4.lox] [0m
[33m[stage-2] [test-4.lox] [0m    if (x > y) {
[33m[stage-2] [test-4.lox] [0m      print "Local x > y";
[33m[stage-2] [test-4.lox] [0m    }
[33m[stage-2] [test-4.lox] [0m
[33m[stage-2] [test-4.lox] [0m    printBoth();
[33m[stage-2] [test-4.lox] [0m  }
[33m[stage-2] [test-4.lox] [0m}
[33m[stage-2] [test-4.lox] [0m
[33m[stage-2] [test-4.lox] [0mif (x == 1 and y == 2) {
[33m[stage-2] [test-4.lox] [0m  print "Globals unchanged:";
[33m[stage-2] [test-4.lox] [0m  printBoth();
[33m[stage-2] [test-4.lox] [0m}
[33m[stage-2] [test-4] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mLocal x: 
[33m[your_program] [0m11
[33m[your_program] [0mLocal y: 
[33m[your_program] [0m19
[33m[your_program] [0mLocal x: 
[33m[your_program] [0m12
[33m[your_program] [0mLocal y: 
[33m[your_program] [0m18
[33m[your_program] [0mLocal x: 
[33m[your_program] [0m13
[33m[your_program] [0mLocal y: 
[33m[your_program] [0m17
[33m[your_program] [0mx is less than y:
[33m[your_program] [0m1
[33m[your_program] [0m2
[33m[your_program] [0mGlobals unchanged:
[33m[your_program] [0mx is less than y:
[33m[your_program] [0m1
[33m[your_program] [0m2
[33m[stage-2] [test-4] [0m[92mâœ“ 19 line(s) match on stdout[0m
[33m[stage-2] [test-4] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-2] [0m[92mTest passed.[0m

[33m[stage-1] [0m[94mRunning tests for Stage #1: gg6[0m
[33m[stage-1] [test-1] [0m[94mRunning test case: 1[0m
[33m[stage-1] [test-1] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-1] [test-1.lox] [0m// This program demonstrates the use of closures to create a counter function.
[33m[stage-1] [test-1.lox] [0m// The inner function count() needs access to the outer function's local variable i.
[33m[stage-1] [test-1.lox] [0m// This can be achieved using closures.
[33m[stage-1] [test-1.lox] [0mfun makeCounter() {
[33m[stage-1] [test-1.lox] [0m  var i = 0;
[33m[stage-1] [test-1.lox] [0m  fun count() {
[33m[stage-1] [test-1.lox] [0m    i = i + 4;
[33m[stage-1] [test-1.lox] [0m    print i;
[33m[stage-1] [test-1.lox] [0m  }
[33m[stage-1] [test-1.lox] [0m
[33m[stage-1] [test-1.lox] [0m  return count;
[33m[stage-1] [test-1.lox] [0m}
[33m[stage-1] [test-1.lox] [0m
[33m[stage-1] [test-1.lox] [0mvar counter = makeCounter();
[33m[stage-1] [test-1.lox] [0mcounter();
[33m[stage-1] [test-1.lox] [0mcounter();
[33m[stage-1] [test-1] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0m4
[33m[your_program] [0m8
[33m[stage-1] [test-1] [0m[92mâœ“ 2 line(s) match on stdout[0m
[33m[stage-1] [test-1] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-1] [test-2] [0m[94mRunning test case: 2[0m
[33m[stage-1] [test-2] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-1] [test-2.lox] [0m// This program uses mutual recursion to determine if a number is even or odd.
[33m[stage-1] [test-2.lox] [0m// It also uses a shared threshold variable that is used to determine if a number is too large to be processed.
[33m[stage-1] [test-2.lox] [0m{
[33m[stage-1] [test-2.lox] [0m  var threshold = 50;
[33m[stage-1] [test-2.lox] [0m
[33m[stage-1] [test-2.lox] [0m  fun isEven(n) {
[33m[stage-1] [test-2.lox] [0m    if (n == 0) return true;
[33m[stage-1] [test-2.lox] [0m    if (n > threshold) return false;
[33m[stage-1] [test-2.lox] [0m    return isOdd(n - 1);
[33m[stage-1] [test-2.lox] [0m  }
[33m[stage-1] [test-2.lox] [0m
[33m[stage-1] [test-2.lox] [0m  fun isOdd(n) {
[33m[stage-1] [test-2.lox] [0m    if (n == 0) return false;
[33m[stage-1] [test-2.lox] [0m    if (n > threshold) return false;
[33m[stage-1] [test-2.lox] [0m    return isEven(n - 1);
[33m[stage-1] [test-2.lox] [0m  }
[33m[stage-1] [test-2.lox] [0m
[33m[stage-1] [test-2.lox] [0m  print isEven(75);
[33m[stage-1] [test-2.lox] [0m}
[33m[stage-1] [test-2] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mfalse
[33m[stage-1] [test-2] [0m[92mâœ“ 1 line(s) match on stdout[0m
[33m[stage-1] [test-2] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-1] [test-3] [0m[94mRunning test case: 3[0m
[33m[stage-1] [test-3] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-1] [test-3.lox] [0m// This program demonstrates the use of closures to create a logger function.
[33m[stage-1] [test-3.lox] [0m// The inner function log() has access to the outer function's local variable logCount.
[33m[stage-1] [test-3.lox] [0m// This is an example of how closures can be used to create private variables and methods.
[33m[stage-1] [test-3.lox] [0mfun makeLogger(prefix) {
[33m[stage-1] [test-3.lox] [0m  var logCount = 0;
[33m[stage-1] [test-3.lox] [0m
[33m[stage-1] [test-3.lox] [0m  fun log(message) {
[33m[stage-1] [test-3.lox] [0m    logCount = logCount + 1;
[33m[stage-1] [test-3.lox] [0m    print prefix + ": " + message;
[33m[stage-1] [test-3.lox] [0m
[33m[stage-1] [test-3.lox] [0m    if (logCount > 3) {
[33m[stage-1] [test-3.lox] [0m      print prefix + ": Too many log lines!";
[33m[stage-1] [test-3.lox] [0m      logCount = 0;
[33m[stage-1] [test-3.lox] [0m    }
[33m[stage-1] [test-3.lox] [0m  }
[33m[stage-1] [test-3.lox] [0m
[33m[stage-1] [test-3.lox] [0m  return log;
[33m[stage-1] [test-3.lox] [0m}
[33m[stage-1] [test-3.lox] [0m
[33m[stage-1] [test-3.lox] [0mvar debugLog = makeLogger("baz");
[33m[stage-1] [test-3.lox] [0mvar errorLog = makeLogger("hello");
[33m[stage-1] [test-3.lox] [0m
[33m[stage-1] [test-3.lox] [0mdebugLog("Starting");
[33m[stage-1] [test-3.lox] [0mdebugLog("Processing");
[33m[stage-1] [test-3.lox] [0mdebugLog("Finishing");
[33m[stage-1] [test-3.lox] [0mdebugLog("Extra line");
[33m[stage-1] [test-3.lox] [0m
[33m[stage-1] [test-3.lox] [0merrorLog("Failed!");
[33m[stage-1] [test-3.lox] [0merrorLog("Retrying...");
[33m[stage-1] [test-3] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mbaz: Starting
[33m[your_program] [0mbaz: Processing
[33m[your_program] [0mbaz: Finishing
[33m[your_program] [0mbaz: Extra line
[33m[your_program] [0mbaz: Too many log lines!
[33m[your_program] [0mhello: Failed!
[33m[your_program] [0mhello: Retrying...
[33m[stage-1] [test-3] [0m[92mâœ“ 7 line(s) match on stdout[0m
[33m[stage-1] [test-3] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-1] [test-4] [0m[94mRunning test case: 4[0m
[33m[stage-1] [test-4] [0m[94mWriting contents to ./test.lox:[0m
[33m[stage-1] [test-4.lox] [0m// This program demonstrates the use of closures to create an accumulator function.
[33m[stage-1] [test-4.lox] [0m// The inner function accumulate() has access to the outer function's local variables sum and count.
[33m[stage-1] [test-4.lox] [0m// This is an example of how closures can be used to create private variables and methods.
[33m[stage-1] [test-4.lox] [0mfun makeAccumulator(label) {
[33m[stage-1] [test-4.lox] [0m  var sum = 0;
[33m[stage-1] [test-4.lox] [0m  var count = 0;
[33m[stage-1] [test-4.lox] [0m
[33m[stage-1] [test-4.lox] [0m  fun accumulate(value) {
[33m[stage-1] [test-4.lox] [0m    sum = sum + value;
[33m[stage-1] [test-4.lox] [0m    count = count + 1;
[33m[stage-1] [test-4.lox] [0m
[33m[stage-1] [test-4.lox] [0m    print label;
[33m[stage-1] [test-4.lox] [0m    print count;
[33m[stage-1] [test-4.lox] [0m    print sum;
[33m[stage-1] [test-4.lox] [0m    print sum;
[33m[stage-1] [test-4.lox] [0m
[33m[stage-1] [test-4.lox] [0m    if (count > 3) {
[33m[stage-1] [test-4.lox] [0m      print "reset";
[33m[stage-1] [test-4.lox] [0m      sum = 0;
[33m[stage-1] [test-4.lox] [0m      count = 0;
[33m[stage-1] [test-4.lox] [0m    }
[33m[stage-1] [test-4.lox] [0m
[33m[stage-1] [test-4.lox] [0m    return sum;
[33m[stage-1] [test-4.lox] [0m  }
[33m[stage-1] [test-4.lox] [0m
[33m[stage-1] [test-4.lox] [0m  return accumulate;
[33m[stage-1] [test-4.lox] [0m}
[33m[stage-1] [test-4.lox] [0m
[33m[stage-1] [test-4.lox] [0mvar acc1 = makeAccumulator("First:");
[33m[stage-1] [test-4.lox] [0mvar acc2 = makeAccumulator("Second:");
[33m[stage-1] [test-4.lox] [0m
[33m[stage-1] [test-4.lox] [0macc1(6);
[33m[stage-1] [test-4.lox] [0macc1(4);
[33m[stage-1] [test-4.lox] [0macc1(3);
[33m[stage-1] [test-4.lox] [0macc1(5);
[33m[stage-1] [test-4.lox] [0m
[33m[stage-1] [test-4.lox] [0macc2(4);
[33m[stage-1] [test-4.lox] [0macc2(5);
[33m[stage-1] [test-4] [0m[94m$ ./your_program.sh run test.lox[0m
[33m[your_program] [0mFirst:
[33m[your_program] [0m1
[33m[your_program] [0m6
[33m[your_program] [0m6
[33m[your_program] [0mFirst:
[33m[your_program] [0m2
[33m[your_program] [0m10
[33m[your_program] [0m10
[33m[your_program] [0mFirst:
[33m[your_program] [0m3
[33m[your_program] [0m13
[33m[your_program] [0m13
[33m[your_program] [0mFirst:
[33m[your_program] [0m4
[33m[your_program] [0m18
[33m[your_program] [0m18
[33m[your_program] [0mreset
[33m[your_program] [0mSecond:
[33m[your_program] [0m1
[33m[your_program] [0m4
[33m[your_program] [0m4
[33m[your_program] [0mSecond:
[33m[your_program] [0m2
[33m[your_program] [0m9
[33m[your_program] [0m9
[33m[stage-1] [test-4] [0m[92mâœ“ 25 line(s) match on stdout[0m
[33m[stage-1] [test-4] [0m[92mâœ“ Received exit code 0.[0m
[33m[stage-1] [0m[92mTest passed.[0m
